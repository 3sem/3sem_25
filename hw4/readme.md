## Анализ работы нескольких способ взаимодействия процессов для передачи большого файла для буфферов разного размера

### Запуск

Запуск по команде 
```
make run
```
будут скомпилированы исполняемые файлы программ А и Б. Сначала запускается программа Б в фоновом режиме, затем А, результат Б записывается в файл, его содержимое выводится на экран.


По команде
```
make clean
```
все созданные файлы будут удалены.

Количество нитей исполнения, точек, пределы интегрирования и максимальное значениие функции на отрезке задаются как агрументы программы А. Для тетов они меняются в мэкфайле.
о
### Анализ данных

По команде 
```
cat /proc/cpuinfo | grep "processor" | wc -l
```
узнаем количество ядер, у меня их 6.

Увеличиваем количество нитей исполнения и замеряем время работы программы, сырые данные в файле data/data/ods


| Число нитей | Время выполнения |
| ------------- | ----- |
| 1             | 0,232 |
| 2             | 0,146 |
| 3             | 0,111 |
| 4             | 0,095 |
| 5             | 0,088 |
| 6             | 0.092 |
| 7             | 0.087 |
| 8             | 0.079 |
| 9             | 0.088 |

Как и ожидалось, время выполнения уменьшается. Ожидалось, что при 6 нитях будет миниамальное время выполнения, но вот у нас получается так, что наоборот, хуже. Хуже даже чем большее количество. Вероятно, 5 лучше, потому что не такая большая конкуренция и оставшееся ядро может заниматься системными задачами. А больше лучше, потому что если одна нить простаивает, в ее время может работать другая, потому что есть "запасные" нити. 